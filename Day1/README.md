# DAY1

## Python基础知识学习：
## 2. 变量、变量类型、作用域

Python 作为动态类型语言，变量无需声明类型，常见类型涵盖字符串（如 `name = "Alice"`）、整数（如 `age = 20`）、列表（如 `grades = [90, 85, 88]`）及字典（如 `info = {"name": "Alice", "age": 20}`）等。变量名区分大小写，可通过 `type()` 函数检查变量类型。类型转换需借助内置函数显式操作，如 `str()`、`int()` 等，但非法转换（如 `int("abc")`）会引发 `ValueError`，此外还可使用 `float()`、`list()`、`bool()` 等进行其他常见类型转换。变量作用域分为全局变量与局部变量，函数内默认无法修改全局变量，若需修改需使用 `global` 关键字声明，且局部变量优先级高于同名全局变量。在代码实践中，变量命名建议采用小写字母与下划线组合（如 `student_name`）；操作前应检查变量类型以避免隐式转换错误；同时，应减少全局变量的使用，优先通过函数参数和返回值。

## 3. 运算符及表达式

在算术运算中，`//` 为整除运算符，其结果向下取整，有别于数学除法；`**` 是幂运算符，相较于 `pow()` 函数更为简洁。逻辑运算里，优先级为 `not > and > or`，且具备短路特性，即 `and` 运算遇假即停、`or` 运算遇真即停。比较运算方面，运算符涵盖 `>、<、==、!=、>=、<=`，并支持链式比较，如 `1 <= a <= 20`。变量作用域分为局部变量与全局变量，局部变量定义于函数内部，仅在函数内可访问；全局变量定义于函数外部，在整个程序中均可访问，若需在函数内修改全局变量，需使用 `global` 关键字，否则对同名变量赋值会创建新的局部变量。需注意避免过度使用全局变量，因其可能导致代码难以维护。

## 4. 语句：条件、循环、异常

在条件判断中，`if-elif-else` 结构用于实现多条件分支，条件表达式（如 `>=`）返回布尔值，程序执行首个满足条件的代码块后即退出判断，该结构适用于成绩评级、权限判断等场景；循环语句里，`for` 循环可遍历可迭代对象（如 `range(5)` 生成 0 - 4），`continue` 用于跳过当前迭代进入下一次循环，而 `break` 会直接终止整个循环；异常处理通过 `try-except` 捕获并处理特定异常（如 `ZeroDivisionError`、`ValueError`），`finally` 块无论是否发生异常都会执行，以此增强程序健壮性；逻辑运算中，`and` 遵循全真为真原则，`or` 遵循一真即真原则，二者均支持短路计算，可用于组合多个判断条件；比较运算使用 `>、<、==、>=、<=、!=` 等运算符，返回布尔值，常用于条件判断；变量作用域方面，全局变量在函数外定义，整个文件可见，局部变量在函数内定义，仅函数内有效，若要在函数内修改全局变量，需使用 `global` 关键字。

## 5. 函数：定义、参数、匿名函数、高阶函数

函数定义通过 `def` 关键字实现，如 `greet(name, greeting="Hello")` 可接受带默认值的参数，调用时未传入的参数将使用默认值（如 `greet("Alice")` 输出 "Hello, Alice!"），传入则覆盖默认值（如 `greet("Bob", "Hi")` 输出 "Hi, Bob!"）；可变参数通过 `*args` 实现，使函数能接收任意数量的位置参数（如 `sum_numbers(*args)` 中 `args` 为包含所有参数的元组，`sum_numbers(1, 2, 3, 4)` 返回 10）；匿名函数（`lambda` 函数）使用 `lambda` 关键字定义，用于实现简单操作（如 `lambda x: x * 2` 将输入值乘以 2，`double(5)` 返回 10），避免了正式函数定义的繁琐；高阶函数以函数为参数或返回值，如 `apply_func(func, value)` 接受函数 `func` 和值 `value` 并调用 `func(value)`，调用时可传入匿名函数（如 `apply_func(lambda x: x ** 2, 4)` 返回 16），从而实现更灵活的代码结构。这些特性共同提升了代码的简洁性、灵活性与可复用性。

## 6. 包和模块：定义模块、导入模块、使用模块、第三方模块

Python 中，模块、第三方模块及包为代码组织与功能扩展提供了重要手段。自定义模块通过将相关功能封装于 `.py` 文件中实现代码复用，使用时以模块名（即文件名，不含 `.py` 后缀）通过 `import` 导入，进而调用其中函数或变量，但需确保模块位于同级目录或 Python 路径中；第三方模块需借助 `pip` 安装（如 `pip install requests`），安装后可利用其提供的功能（如 `requests.get()` 发送 HTTP GET 请求、`response.status_code` 获取响应状态码），常用于调用 Web API（如 GitHub API）及网络爬虫等场景；包是包含 `__init__.py` 文件（Python 3.3+ 可省略）的目录，用于组织多个模块形成层级结构，导入时可通过 `from 包名 import 模块名` 或 `from 包名.模块名 import 函数名` 的方式。关键总结如下：自定义模块通过 `.py` 文件封装功能并经 `import` 导入；第三方模块需经 `pip` 安装以扩展 Python 功能；包借助目录组织模块，通常需 `__init__.py` 文件（Python 3.3+ 可选）。在模块与包的使用过程中，需注意路径问题，确保其位于 `sys.path` 包含的路径中，否则会引发 `ModuleNotFoundError`。若导入失败，应检查文件路径是否正确，并可通过打印 `sys.path` 查看 Python 搜索路径。此外，在包内模块中，推荐使用绝对导入（完整路径）以避免潜在问题。

## 7. 类和对象

通过实现 `Student` 类及其子类 `GradStudent`，系统掌握了面向对象编程中类定义、继承与方法重写的核心机制。在基类中，通过 `__init__` 方法初始化属性（`name`、`age`），并定义 `introduce()` 方法实现基础功能；子类通过 `super()` 调用父类构造方法，扩展 `major` 属性，并重写 `introduce()` 以体现多态性。实例化测试验证了继承层级中方法的正确调用：基类输出基础信息（如 `Alice, 20`），子类输出扩展信息（如 `Bob, CS`）。此案例清晰展示了类继承的代码复用优势及多态的实际应用。

## 8. 装饰器

Python 装饰器包含简单装饰器与带参数的装饰器两种类型。简单装饰器本质是高阶函数，它接受一个函数作为参数并返回一个新的函数（`wrapper`），使用 `@my_decorator` 语法糖等价于 `say_hello = my_decorator(say_hello)`，调用被装饰函数时实际执行的是 `wrapper()` 函数，借此可在 `wrapper` 中控制原函数的执行时机，如在前后添加逻辑，常应用于日志记录、权限校验、性能测试（如计算函数执行时间）等场景。带参数的装饰器具有三层嵌套结构，外层 `repeat(n)` 接收装饰器参数（如 `n=3`），中层 `decorator(func)` 接收被装饰的函数，内层 `wrapper(*args, **kwargs)` 处理函数调用，其中 `*args` 和 `**kwargs` 确保被装饰函数的参数能正确传递，例如 `greet("Alice")` 中的 `"Alice"` 通过 `args` 传递给原函数，此类装饰器适用于重试机制（如网络请求失败后自动重试）、批量操作等场景。此外，装饰器依赖闭包（函数嵌套 + 内部函数引用外部变量）保存状态，Python 中函数作为一等公民，可作为参数或返回值传递，语法糖 `@` 是 `func = decorator(func)` 的简写形式，多个装饰器按从下到上的顺序执行（如 `@d1 @d2 def f()` 等价于 `d1(d2(f))`）。

## 9. 文件操作

在 Python 中，文件操作涵盖文件读写与 CSV 文件处理。文件读写方面，写文件时使用 `open()` 函数以 `"w"` 模式打开文件，该模式可在文件不存在时创建新文件，若文件已存在则会覆盖原有内容，随后通过 `f.write()` 方法将数据写入文件；读文件时以 `"r"` 模式打开文件，表示以只读方式读取内容，借助 `f.read()` 方法可将整个文件内容读取到字符串中并打印。同时，采用 `with` 语句处理文件操作，其优势在于能自动关闭文件，无需手动调用 `f.close()`，可有效避免资源泄露问题。CSV 文件操作则借助 `csv` 模块，首先使用 `open()` 函数以 `"w"` 模式打开文件，并设置 `newline=""` 以防止写入时出现额外空行，接着利用 `csv.writer()` 创建 CSV 写入对象，最后通过 `writer.writerow()` 方法将每一行数据（以列表形式传入，代表 CSV 文件中的每一列）写入 CSV 文件。通过上述操作，我们掌握了 Python 基本文件读写方法，学会了处理 CSV 文件并按行存储数据，同时利用 `with` 语句简化了文件操作流程，规避了手动管理文件关闭的繁琐与潜在问题。



# 哨兵2号卫星影像处理

该代码实现了对哨兵2号(Sentinel-2)卫星多光谱遥感影像的专业处理，主要功能包括：
![Uploading image.png…]()

## 1. 核心功能概述：
- 读取包含5个波段（B02蓝、B03绿、B04红、B08近红外、B12短波红外）的TIFF文件
- 通过波段合成生成RGB真彩色图像
- 将原始16位数据（0-10000范围）压缩至8位标准图像范围（0-255）
- 实现原始影像与处理结果的对比可视化

## 2. 关键技术实现：
- **数据读取**：采用`rasterio.open()`专业库替代GDAL，轻量高效处理GeoTIFF格式
- **波段处理**：`src.read()`获取形状为(波段数, 高度, 宽度)的多维NumPy数组
- **色彩合成**：`np.dstack()`深度堆叠R/G/B波段形成(H,W,3)的RGB图像
- **值域压缩**：采用百分位拉伸法（`np.percentile()`+线性变换），默认使用2%-98%范围排除异常值
- **可视化对比**：`plt.subplot()`实现AB对比展示效果

## 3. 核心函数说明：
def percentile_stretch(band, lower=2, upper=98):
    p_low, p_high = np.percentile(band, (lower, upper))
    return np.clip((band - p_low)/(p_high - p_low)*255, 0, 255)
- 该自适应拉伸函数返回0到255范围的uint8数据，有效提升图像对比度。

## 4. 数据处理流程：
- **数据校验**：强制检查输入波段数量（`if bands.shape[0] != 5`）
- **类型转换**：`astype(float)`避免整数运算溢出
- **可视化布局**：左右分列显示原始影像（简单/10000缩放）与专业处理结果

## 5. 优化建议：
- **元数据管理**：保存RGB时可更新元数据（`profile.update(count=3, dtype='uint8')`）
- **功能扩展**：增加NDVI计算（`(nir - red) / (nir + red + 1e-10)`）
- **异常处理**：增强文件读取错误处理（`except rasterio.RasterioIOError`）

## 6. 技术总结：
- **处理流程**：数据读取 → 波段分离 → 色彩合成 → 值域压缩 → 可视化
- **关键技巧**：`with`语句资源管理、NumPy数组操作（`astype()`, `clip()`）、Matplotlib子图展示

## 应用场景：
- 卫星影像真彩色可视化
- 遥感数据预处理（深度学习输入）
- 地物分类与变化检测
